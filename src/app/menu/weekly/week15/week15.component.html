<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> What Is a HEAD in Git? </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<ul> 
		<li><p><a href="https://www.cloudbees.com/blog/git-detached-head">Link	1</a></p></li>
		<li><p><a href="https://www.git-tower.com/learn/git/faq/save-changes-with-git-stash/">Link 2: Git stash</a></p></li>
	</ul>
	<p>What
	does HEAD mean in Git? To understand that, we have to take a step
	back and talk fundamentals.</p>
	<p>A
	Git repository is a collection of <b>objects</b>
	and <b>references</b>.
	Objects have relationships with each other, and references point to
	objects and to other references. The main objects in a Git repository
	<a>blobs</a>
	<a>trees</a>.
	<a>branches</a>,
	which you can think of as labels you put on a commit.</p>
	<p>HEAD
	is another important type of reference. The purpose of HEAD is to
	keep track of the current point in a Git repo. In other words, HEAD
	answers the question, “Where am I right now?”</p>
	<h2>Are you in ‘detached HEAD’
	state?</h2>
	<p>Most
	of the time, HEAD points to a branch name. When you add a new commit,
	your branch reference is updated to point to it, but HEAD remains the
	same. When you change branches, HEAD is updated to point to the
	branch you’ve switched to. All of that means that, in these
	scenarios, HEAD is synonymous with “the last commit in the current
	branch.” This is the <i>normal</i>
	state, in which HEAD is <i>attached</i>
	to a branch.</p>
		<div class='images'><img src='assets/Week 15/1.png'></div>		<div class='images'><img src='assets/Week 15/2.png'></div>	<p>This
	is the detached HEAD state; HEAD is pointing directly to a commit
	instead of a branch.</p>
	<h2>Benefits of a Git Detached
	HEAD</h2>
	<p>You
	are in 'detached HEAD' state. You can look around, make experimental
	changes and commit them, and you can discard any commits you make in
	this state without impacting any branches by switching back to a
	branch.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Big O notation  </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<ul>
		<li><p><a href="https://www.youtube.com/watch?v=waPQP2TDOGE">Link
			1</a></p></li>
		<li><p><a href="https://www.youtube.com/watch?v=v4cd1O4zkGw">Link
			2</a></p></li>
		<li><p><a href="https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/">Link
			3</a></p></li>
	</ul>
	<h2>1. What is Big O Notation, and
	why does it matter</h2>
	<ul>
	<li><p>Big
		O notation is a mathematical notation that describes the limiting
		behavior of a function when the argument tends towards a particular
		value or infinity.”</p></li>
	<li><p>describes
		the <b>complexity</b>
		of your code using algebraic terms.</p></li>
	</ul>
	<p>When
	we calculate big O notation, we only care about the <b>dominant
	terms</b>,
	and we do not care about the coefficients. 
	</p>
	<p><b>2.
	Formal Definition of Big O notation</b></p>
		<div class='images'><img src='assets/Week 15/3.png'></div>	<p><b>3.
	Big O, Little O, Omega &amp; Theta</b></p>
		<div class='images'><img src='assets/Week 15/4.png'></div>	<ul>
	<li><p><b>Big
		O (O())</b>
		describes the <b>upper
		bound</b>
		of the complexity.</p></li>
	<li><p><b>Omega
		(Ω())</b>
		describes the <b>lower
		bound</b>
		of the complexity.</p></li>
	<li><p><b>Theta
		(Θ())</b>
		describes the <b>exact
		bound</b>
		of the complexity.</p></li>
	<li><p><b>Little
		O (o())</b>
		describes the <b>upper
		bound excluding the exact bound</b>.</p></li>
	</ul>
		<div class='images'><img src='assets/Week 15/5.png'></div>		<div class='images'><img src='assets/Week 15/6.png'></div>		<div class='images'><img src='assets/Week 15/7.png'></div>	<p><b>4.
	Complexity Comparison Between Typical Big Os</b></p>
		<div class='images'><img src='assets/Week 15/8.png'></div>		<div class='images'><img src='assets/Week 15/9.png'></div>	<h2>Big O Rules</h2>
	<ol>
	<li><p><b>O(1)
		has the least complexity: </b>Often
		called <i>“constant
		time”</i></p></li>
	<li><p><b>O(log(n))
		is more complex than O(1), but less complex than polynomials</b></p></li>
	<li><p><b>Complexity
		of polynomials increases as the exponent increases</b></p></li>
	<li><p><b>Exponentials
		have greater complexity than polynomials as long as the coefficients
		are positive multiples of n </b>O(2ⁿ)
		is more complex than O(n⁹⁹)</p></li>
	<li><p><b>Factorials
		have greater complexity than exponentials</b></p></li>
	<li><p><b>Multiplying
		terms: </b>When
		multiplying, the complexity will be greater than the original, but
		no more than the equivalence of multiplying something that is more
		complex. 
		</p></li>
	<li><p><b>Time
		&amp; Space Complexity: </b>
		The space complexity is related to how much memory the program will
		use<br>
		</p></li>
	</ol>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> JAVA </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<h2><a href="https://nam10.safelinks.protection.outlook.com/GetUrlReputation">Nested Classes</a></h2>
	<p>The
	Java programming language allows you to define a class within another
	class. Such a class is called a <i>nested
	class</i>.</p>
	<p><b>Terminology:</b>
	Nested classes are divided into two categories: non-static and
	static. Non-static nested classes are called <i>inner
	classes</i>.
	Nested classes that are declared static are called <i>static
	nested classes</i>.</p>
	<p>A
	nested class is a member of its enclosing class. Non-static nested
	classes (inner classes) have access to other members of the enclosing
	class, even if they are declared private. Static nested classes do
	not have access to other members of the enclosing class. 
	</p>
	<h3>Why Use Nested Classes?</h3>
	<p>Compelling
	reasons for using nested classes include the following:</p>
	<ul>
	<li><p><b>It
		is a way of logically grouping classes that are only used in one
		place</b>:
		If a class is useful to only one other class, then it is logical to
		embed it in that class and keep the two together. Nesting such
		&quot;helper classes&quot; makes their package more streamlined.</p></li>
	<li><p><b>It
		increases encapsulation</b>:
		Consider two top-level classes, A and B, where B needs access to
		members of A that would otherwise be declared private. By hiding
		class B within class A, A's members can be declared private and B
		can access them. In addition, B itself can be hidden from the
		outside world.</p></li>
	<li><p><b>It
		can lead to more readable and maintainable code</b>:
		Nesting small classes within top-level classes places the code
		closer to where it is used.</p></li>
	</ul>
	<h2><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">Local
	Classes</a></h2>
	<p>Local
	classes are classes that are defined in a <i>block</i>,
	which is a group of zero or more statements between balanced braces.
	You typically find local classes defined in the body of a method.</p>
	<h2><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html">When
	to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda
	Expressions</a></h2>
	<p>As
	<a>Nested
	Classes</a>, nested classes enable you to logically group classes
	that are only used in one place, increase the use of encapsulation,
	and create more readable and maintainable code. Local classes,
	anonymous classes, and lambda expressions also impart these
	advantages; however, they are intended to be used for more specific
	situations:</p>
	<ul>
		<li><p><a>Local
		class</a>: Use it if you need to create more than one instance of a
		class, access its constructor, or introduce a new, named type
		(because, for example, you need to invoke additional methods later).</p></li>
		<li><p><a>Anonymous	class</a>: Use it if you need to declare fields or additional methods.</p></li>
		<li><p><a>Lambda
		expression</a>:</p></li>
		<ul>
			<li><p>Use
			it if you are encapsulating a single unit of behavior that you want
			to pass to other code. For example, you would use a lambda
			expression if you want a certain action performed on each element
			of a collection, when a process is completed, or when a process
			encounters an error.</p>
			</li>
			<li><p>Use
			it if you need a simple instance of a functional interface and none
			of the preceding criteria apply (for example, you do not need a
			constructor, a named type, fields, or additional methods).</p>
			</li>
		</ul>
		<li><p><a>Nested
		class</a>: Use it if your requirements are similar to those of a
		local class, you want to make the type more widely available, and
		you don't require access to local variables or method parameters.</p></li>
		<ul>
			<li><p>Use
			a non-static nested class (or inner class) if you require access to
			an enclosing instance's non-public fields and methods. Use a static
			nested class if you don't require this access.</p></li>
		</ul>
	</ul>
	<h2><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">Syntax of Anonymous Classes</a></h2>
	<p>As
	mentioned previously, an anonymous class is an expression. The syntax
	of an anonymous class expression is like the invocation of a
	constructor, except that there is a class definition contained in a
	block of code.</p>
	<p>Consider
	the instantiation of the frenchGreeting object:</p>
	<code>
		<p>HelloWorld
	frenchGreeting = new HelloWorld() {{ '{' }} </p>
	<p>String
	name = &quot;tout le monde&quot;;</p>
	<p>public
	void greet() {{ '{' }} </p>
	<p>greetSomeone(&quot;tout
	le monde&quot;);</p>
	<p>{{ '}' }} </p>
	<p>public
	void greetSomeone(String someone) {{ '{' }} </p>
	<p>name
	= someone;</p>
	<p>               
	System.out.println(&quot;Salut
	&quot; + name);</p>
	<p>{{ '}' }} </p>
	<p>{{ '}' }} ;</p>
	</code>
	<p>The
	anonymous class expression consists of the following:</p>
	<ul>
	<li><p>The
		new operator</p></li>
	<li><p>The
		name of an interface to implement or a class to extend. In this
		example, the anonymous class is implementing the interface
		HelloWorld.</p></li>
	<li><p>Parentheses
		that contain the arguments to a constructor, just like a normal
		class instance creation expression. <b>Note</b>:
		When you implement an interface, there is no constructor, so you use
		an empty pair of parentheses, as in this example.</p></li>
	<li><p>A
		body, which is a class declaration body. More specifically, in the
		body, method declarations are allowed but statements are not.</p></li>
	</ul>
	<p>Because
	an anonymous class definition is an expression, it must be part of a
	statement. In this example, the anonymous class expression is part of
	the statement that instantiates the frenchGreeting object. (This
	explains why there is a semicolon after the closing brace.)</p>
	<h2>VIM</h2>
	<h2><a href="https://www.cyberciti.biz/faq/turn-on-or-off-color-syntax-highlighting-in-vi-or-vim/">How
	to enable vim syntax colors option</a></h2>
	<ol>
	<li><p>Edit
		~/.vimrc file by typing the command: <b>vi
		~/.vimrc</b></p></li>
	<li><p>Append
		the following option</p></li>
	<li><p><b>syntax
		on</b></p></li>
	<li><p>Save
		and close the file</p></li>
	<li><p>Test
		it by running vim command: <b>vim
		foo.sh</b></p></li>
	</ol>
	<p>Let
	us see all steps in details for turning on or off color syntax
	highlighting under Linux, macOS and Unix-like system when using vim
	text editor.</p>
	<h2><a href="https://www.cyberciti.biz/faq/vi-show-line-numbers/">Make
	the vi/vim text editor show or hide line numbers</a></h2>
	<p>Vim
	can display line numbers in the left margin:</p>
	<ol>
        <li><p>Press ESC key</p></li>
        <li><p>At the : prompt type the following command to run on line numbers: <b>set
		number</b></p></li>
	<li><p>To
		turn off line numbering, type the following command at the : prompt
		<b>set
		nonumber</b></p></li>
	</ol>

</mat-expansion-panel>