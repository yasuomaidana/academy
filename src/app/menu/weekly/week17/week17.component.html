<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> The Inner Game of Tennis by Timothy Gallwey </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>The best performance comes when you are not thinking on it.</p>
	<p>Every game is composed of two parts:</p>
	<ul>
	<li><p>the
		outer game</p>
	<li><p>the
		inner game: This is the game that takes place in the mind of the
		player, and it is played against such obstacles as lapses in
		concentration, nervousness, self-doubt and self-condemnation. In
		short, it is played to overcome all habits of mind which inhibit
		excellence in performance.</p>
	</ul>
	<p>If
	you focused too much in winning you are not going to winning. You
	must be focused on what you are doing rather than the possible
	results.</p>
	<p>Sometimes,
	the problem is not that you don't know what you should be doing, but
	you don't do what you know.  You have to focus on improve your skills
	and work on that. While you are acquiring new tools/knowledge. If you
	focus on what you do not have/know, you will be oversaturated and
	lose your path quickly.</p>
	<p>You
	are the one that are controlling your actions, yeah it is true that
	sometimes there are several thing that you can’t control, like
	weather, etc… However, you can control your own time, and your
	effort.</p>
	<p>Some
	wills and habits are like an elephant, you can’t move/force an
	elephant instantly, but you can induct its direction. Creating habits
	and skills takes times.</p>
	<p>You
	have to make high intensity trainings often, this will accustom you
	to make some performance as a natural state. It also will help you
	with your self-confidence.</p>
	<p>You
	optimize your time through inner exploration, you identify which
	fields you want to explore and focused more on them. It is true, that
	organizing your time with calendars etc… is very effective,
	however, filling all your day with activities is not the answer.</p>
	<p>Play
	games or do a hobby is highly recommended to discharge your mind.
	However, watch things maybe is not an efficient way to do it.</p>
	<p>An
	opponent is only a way to proof yourself.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Java Swing  </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p><a href="https://www.javatpoint.com/java-swing">Tutorial</a></p>
	<p><b>Java
	Swing tutorial</b>
	is a part of Java Foundation Classes (JFC) 
	</p>
	<ul>
	<li><p><i>Used
		to create window-based applications</i>.
		</p>
	<li><p>It
		is built on the top of AWT (Abstract Windowing Toolkit) API and
		entirely written in java.</p>
	</ul>
	<h2>AWT vs Swing</h2>
	<table>
	<col>
	<col>
	<tr>
	<td>
	<p><b>Java
				AWT</b></p>
			</td>
	<td>
	<p><b>Java
				Swing</b></p>
			</td>
		</tr>
	<tr>
	<td>
	<p>AWT
				components are <b>platform-dependent</b>.</p>
			</td>
	<td>
	<p>Java
				swing components are <b>platform-independent</b>.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>AWT
				components are <b>heavyweight</b>.</p>
			</td>
	<td>
	<p>Swing
				components are <b>lightweight</b>.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>AWT
				<b>doesn't
				support pluggable look and feel</b>.</p>
			</td>
	<td>
	<p>Swing
				<b>supports
				pluggable look and feel</b>.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>AWT
				provides <b>less
				components</b>
				than Swing.</p>
			</td>
	<td>
	<p>Swing
				provides <b>more
				powerful components</b>
				such as tables, lists, scrollpanes, colorchooser, tabbedpane etc.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>AWT
				<b>doesn't
				follows MVC</b>(Model
				View Controller) where model represents data, view represents
				presentation and controller acts as an interface between model and
				view.</p>
			</td>
	<td>
	<p>Swing
				<b>follows
				MVC</b>.</p>
			</td>
		</tr>
	</table>
	<h2>Hierarchy of Java Swing
	classes</h2>
		<div class='images'><img src='assets/Week 17/1.png'></div>
</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Runtime </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>Runtime
	describes software/instructions that are executed <i>while</i>
	your program is running, especially those instructions that you did
	not write explicitly, but are necessary for the proper execution of
	your code.</p>
	<p>Low-level
	languages like C have very small (if any) runtime. More complex
	languages like Objective-C, which allows for dynamic message passing,
	have a much more extensive runtime.</p>
	<p>You
	are correct that runtime code is library code, but library code is a
	more general term, describing the code produced by <i>any</i>
	library. Runtime code is specifically the code required to implement
	the features of the language itself.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Vector vs Array List (Java) </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p><a href="https://www.geeksforgeeks.org/vector-vs-arraylist-java/">Link</a></p>
	<ul>
	<li><p><b>Synchronization
		:</b>
		Vector is <b>synchronized</b>,
		which means only one thread at a time can access the code, while
		arrayList is<b>
		not synchronized</b>,
		which means multiple threads can work on arrayList at the same time.
		</p>
	<li><p>If
		multiple threads access arrayList concurrently, then we <b>must
		synchronize</b>
		the block of the <b>code
		which modifies</b>
		the list <b>structurally,</b>
		or alternatively allow simple element modifications. Structural
		modification means addition or deletion of element(s) from the list.
		Setting the value of an existing element is not a structural
		modification.</p>
	</ul>
		<div class='images'><img src='assets/Week 17/2.png'></div>	<ul>
	<li><p><b>Performance:</b>
		<b>ArrayList
		is faster</b>,
		since it is non-synchronized, while vector operations give slower
		performance since they are synchronized (thread-safe). If on</p>
	<li><p>e
		thread works on a vector, it has acquired a lock on it, which forces
		any other thread wanting to work on it to have to wait until the
		lock is released.</p>
	<li><p><b>Data
		Growth:</b>
		ArrayList and Vector <b>both
		grow and shrink dynamically </b>to
		maintain optimal use of storage – but the way they resize is
		different. ArrayList increments 50% of the current array size if the
		number of elements exceeds its capacity, while vector increments
		100% – essentially doubling the current array size.</p>
	<li><p><b>Traversal:</b>
		Vector can use both <a href="https://www.geeksforgeeks.org/iterators-in-java/">Enumeration
		and Iterator</a>
		for traversing over elements of vector while ArrayList can only use
		<b>Iterator</b>
		for traversing.</p>
	<li><p><b>Applications
		:</b>
		Most of the time, programmers prefer ArrayList over Vector because
		<a href="https://www.geeksforgeeks.org/synchronization-arraylist-java/">ArrayList
		can be synchronized explicitly using Collections.synchronizedList</a>.</p>
	</ul>
	<table>
	<col>
	<col>
	<tr>
	<td>
	<p><b>ArrayList</b></p>
			</td>
	<td>
	<p><b>Vector</b></p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Array
				List is not synchronized.</p>
			</td>
	<td>
	<p>Vector
				is synchronized.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Array
				List is fast as it’s non-synchronized.</p>
			</td>
	<td>
	<p>Vector
				is slow as it is thread safe.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>If
				an element is inserted into the Array List, it increases its Array
				size by 50%.</p>
			</td>
	<td>
	<p>Vector
				defaults to doubling size of its array.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Array
				List does not define the increment size.</p>
			</td>
	<td>
	<p>Vector
				defines the increment size.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Array
				List can only use Iterator for traversing an Array List.</p>
			</td>
	<td>
	<p>Vector
				can use both Enumeration and Iterator for traversing.</p>
			</td>
		</tr>
	</table>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Iterator vs Enumeration </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p><a href="https://www.geeksforgeeks.org/difference-between-iterator-and-enumeration-in-java-with-examples/">Link
	1</a></p>
	<p><a href="https://www.geeksforgeeks.org/iterators-in-java/">Link
	2</a></p>
	<p>The
	functionality of Enumeration and the Iterator are same. Using
	Enumeration you can only traverse and fetch the objects, where as
	using Iterator we can also add and remove the objects. So Iterator
	can be useful if you want to manipulate the list and Enumeration is
	for read-only access. 
	</p>
	<table>
	<col>
	<col>
	<tr>
	<td>
	<p>Iterator</p>
			</td>
	<td>
	<p>Enumeration</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Iterator
				is a universal cursor as it is applicable for all the collection
				classes.</p>
			</td>
	<td>
	<p>Enumeration
				is not a universal cursor as it applies only to legacy classes.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Iterator
				has the remove() method.</p>
			</td>
	<td>
	<p>Enumeration
				does not have the remove() method.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Iterator
				can do modifications (e.g using remove() method it removes the
				element from the Collection during traversal).</p>
			</td>
	<td>
	<p>Enumeration
				interface acts as a read only interface, one can not do any
				modifications to Collection while traversing the elements of the
				Collection.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Iterator
				is not a legacy interface. Iterator can be used for the traversal
				of HashMap, LinkedList, ArrayList, HashSet, TreeMap, TreeSet .</p>
			</td>
	<td>
	<p>Enumeration
				is a legacy interface which is used for traversing Vector,
				Hashtable.</p>
			</td>
		</tr>
	</table>
		<div class='images'><img src='assets/Week 17/3.png'></div>
</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Java (JVM) Memory Model </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    			<div class='images'><img src='assets/Week 17/4.png'></div>	<p>The
	young generation is the place where all the new objects are created.
	When the young generation is filled, garbage collection is performed.
	This garbage collection is called Minor GC. Young Generation is
	divided into three parts – Eden Memory and two Survivor Memory
	spaces.
	</p>
	<h2>Important Points about
	Generation Spaces:</h2>
	<ul>
	<li><p>Most
		of the newly created objects are located in the Eden memory space.</p>
	</ul>
	<ol>
	<li><p>When
		Eden space is filled with objects: 
		</p>
	<ul>
	<li><p>Minor
			GC is performed and all the survivor objects are moved to one of
			the survivor spaces.</p>
		</ul>
	<li><p>Minor
		GC also checks the survivor objects and move them to the other
		survivor space. 
		</p>
	<ul>
	<li><p>So
			at a time, one of the survivor space is always empty.</p>
		</ul>
	<li><p>Objects
		that are survived after many cycles of GC, are moved to the Old
		generation memory space. 
		</p>
	<ul>
	<li><p>Usually,
			it’s done by setting a threshold for the age of the young
			generation objects before they become eligible to promote to Old
			generation.</p>
		</ul>
	</ol>
	<p>Old
	Generation memory contains the objects that are long-lived and
	survived after many rounds of Minor GC. Usually, garbage collection
	is performed in Old Generation memory when it’s full. Old
	Generation Garbage Collection is called Major GC and usually takes a
	longer time.</p>
	<h2>Stop the World Event</h2>
	<p>All
	the Garbage Collections are “Stop the World” events because all
	application threads are stopped until the operation completes.</p>
	<p>Since
	Young generation keeps short-lived objects, Minor GC is very fast and
	the application doesn’t get affected by this.</p>
	<p>Major
	GC takes a long time because it checks all the live objects. 
	</p>
	<p>Major
	GC should be minimized because it will make your application
	unresponsive for the garbage collection duration. 
	</p>
	<h2>Java Memory Model –
	Permanent Generation</h2>
	<ul>
	<li><p>Permanent
		Generation or “Perm Gen” contains the application metadata
		required by the JVM to describe the classes and methods used in the
		application. Note that Perm Gen <b>is
		not part of Java Heap memory.</b></p>
	<li><p>Perm
		Gen is populated by JVM at runtime based on the classes used by the
		application. Perm Gen also contains Java SE library classes and
		methods. Perm Gen objects are garbage collected in a full garbage
		collection.</p>
	</ul>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Java Garbage Collection </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>Java
	Garbage Collection is the process to identify and remove the unused
	objects from the memory and free space to be allocated to objects
	created in future processing. One of the best features of Java
	programming language is the automatic garbage collection, unlike
	other programming languages such as C where memory allocation and
	deallocation is a manual process.</p>
	<p>Garbage
	Collector is the program running in the background that looks into
	all the objects in the memory and find out objects that are not
	referenced by any part of the program. All these unreferenced objects
	are deleted and space is reclaimed for allocation to other objects.
	</p>
	<h2>Basic garbage collector steps:</h2>
	<ol>
	<li><p>Marking:
		This is the first step where garbage collector identifies which
		objects are in use and which ones are not in use.</p>
	<li><p>Normal
		Deletion: Garbage Collector removes the unused objects and reclaim
		the free space to be allocated to other objects.</p>
	<li><p>Deletion
		with Compacting: For better performance, after deleting unused
		objects, all the survived objects can be moved to be together. This
		will increase the performance of allocation of memory to newer
		objects.</p>
	</ol>
	<h2>Problems with a simple mark
	and delete approach.</h2>
	<ul>
	<li><p>First
		one is that it’s not efficient because most of the newly created
		objects will become unused</p>
	<li><p>Secondly
		objects that are in-use for multiple garbage collection cycle are
		most likely to be in-use for future cycles too.</p>
	</ul>
	<p>The
	above shortcomings with the simple approach is the reason that Java
	Garbage Collection is Generational and we have Young Generation and
	Old Generation spaces in the heap memory.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Idempotence </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p><a href="https://www.restapitutorial.com/lessons/idempotency.html"><b>Link</b></a></p>
	<p>From
	a RESTful service standpoint, for an operation (or service call) to
	be idempotent, clients can make that same call repeatedly while
	producing the same result. In other words, making multiple identical
	requests has the same effect as making a single request. Note that
	while idempotent operations produce the same result on the server (no
	side effects), the response itself may not be the same (e.g. a
	resource's state may change between requests).</p>
	<p>The
	PUT and DELETE methods are defined to be idempotent. However, there
	is a caveat on DELETE. The problem with DELETE, which if successful
	would normally return a 200 (OK) or 204 (No Content), will often
	return a 404 (Not Found) on subsequent calls, unless the service is
	configured to &quot;mark&quot; resources for deletion without
	actually deleting them. However, when the service actually deletes
	the resource, the next call will not find the resource to delete it
	and return a 404. However, the state on the server is the same after
	each DELETE call, but the response is different.</p>
	<p>GET,
	HEAD, OPTIONS and TRACE methods are defined as safe, meaning they are
	only intended for retrieving data. This makes them idempotent as well
	since multiple, identical requests will behave the same.
	</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Some Java questions </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    			<div class='images'><img src='assets/Week 17/5.png'></div>
</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Testing </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    			<div class='images'><img src='assets/Week 17/6.png'></div>		<div class='images'><img src='assets/Week 17/7.png'></div>		<div class='images'><img src='assets/Week 17/8.png'></div>	<p>
	<br><br>
	</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> ACID properties of transactions </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    			<div class='images'><img src='assets/Week 17/9.png'></div>
</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Databases </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p><a href="https://www.xplenty.com/blog/which-database/">Link
	1</a></p>
	<p><a href="https://www.xplenty.com/blog/the-sql-vs-nosql-difference/">Link
	2</a></p>
		<div class='images'><img src='assets/Week 17/10.png'></div>	<h2>Relational Database Management
	Systems (SQL-Based)</h2>
	<p>Relational
	database management systems (RDBMSs) use SQL, a database management
	language that offers a highly organized and structured approach to
	information management.</p>
	<p>The
	primary reasons why SQL-based RDBMSs continue to dominate are: 
	</p>
	<ol>
	<li><p>They
		are highly stable and reliable</p>
	<li><p>They
		adhere to a standard that integrates seamlessly with popular
	<a href="https://www.liquidweb.com/kb/what-is-a-lamp-stack/?utm_source=xplenty&amp;utm_medium=blog&amp;utm_campaign=content">LAMP</a></p>
	<li><p>We've
		been using them for more than 40 years.</p>
	</ol>
	<h2>RDBMS advantages:</h2>
	<ul>
	<li><p><b>ACID
		compliance: </b>The
		more ACID-compliant a database is, the more it serves to guarantee
		the validity of database transactions, reduce anomalies, safeguard
		data integrity, and create stable database systems. Generally,
		SQL-based RDBMSs achieve a high level of ACID compliance, but NoSQL
		databases give up this distinction to gain speed and flexibility
		when dealing with unstructured data.</p>
	<li><p><b>Ideal
		for consistent data systems: </b>With
		a SQL-based RDBMS, your information will remain in the structure you
		originally create. If you don't need a dynamic information system
		for massive amounts of data—and you're not dealing with numerous
		data types—an RDBMS offers great speed and stability.</p>
	<li><p><b>Better
		support options: </b>Because
		RDBMS databases have been around for over 40 years, it's easier to
		get support, add-on products, and integrate data from other systems.</p>
	</ul>
	<h2>RDBMS disadvantages:</h2>
	<ul>
	<li><p><b>Scalability
		challenges and difficulties with sharding: </b>
		</p>
	<ul>
	<li><p>RDBMSs
			have a more difficult time scaling up in response to massive growth
			compared to NoSQL databases. 
			</p>
	<li><p>These
			databases also present challenges when it comes to sharding. 
			</p>
	<ul>
	<li><p>Sharding
				is the process of dividing a large database into smaller parts for
				easier management. If you're dealing with a conservative database
				that you don't expect to change a lot in the years ahead, the
				sharding and scaling challenges related to RDBMS solutions may
				never apply to you. On the other hand, if you plan to scale up and
				grow in the years ahead, a non-relational database system
				(NoSQL-based) could be a better match for your needs.</p>
			</ul>
		</ul>
	<li><p><b>Less
		efficient with NoSQL formats: </b>Most
		RDBMSs are now compatible with NoSQL data formats, but they don't
		work with them as efficiently as non-relational databases.</p>
	</ul>
	<h2>Non-Relational Database
	Systems (NoSQL-based)</h2>
	<p>Non-relational
	databases let you organize information in a looser fashion—kind of
	like dropping the information in different file folders. This is
	important for two reasons: 
	</p>
	<ol>
	<li><p>You
		can store unstructured information and expose it to powerful
		business intelligence systems that will analyze it with AI
		algorithms</p>
	<li><p>You
		can store unstructured data that you plan to structure later.</p>
	</ol>
	<h2>Non-relational DBMS
	advantages:</h2>
	<ul>
	<li><p><b>Excellent
		for handling &quot;big data&quot; analytics: </b>They
		remove the bottleneck of needing to categorize and apply strict
		structures to massive amounts of information. NoSQL databases
		support the speed and efficiency of server operations while offering
		the capacity to work with large amounts of data.</p>
	<li><p><b>No
		limits on types of data you can store</b></p>
	<li><p><b>Easier
		to scale</b></p>
	<li><p><b>No
		data preparation required</b></p>
	</ul>
	<h2>Non-relational DBMS
	disadvantages:</h2>
	<ul>
	<li><p><b>More
		difficult to find support</b></p>
	<li><p><b>Lack
		of tools: </b>There
		aren't as many tools to assist with performance testing and
		analysis.</p>
	<li><p><b>Compatibility
		and standardization challenges:</b>
		Newer NoSQL database systems also lack the high degree of
		compatibility and standardization offered by SQL-based alternatives.
		You may find that the data in your non-relational database
		management system doesn't readily integrate with other products and
		services.</p>
	</ul>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
        <mat-panel-title>
            <p> Different Types of Non-Relational Databases </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    <h2>Graph stores</h2>
    <p>These types of databases make data visualization easier. They are
	great at storing relationships between diverse data points with the
	help of nodes. Graph stores may not be the most scalable databases.
	However, they are efficient at use cases such as fraud prevention.</p>
    <h2>Column stores</h2>
	<p>There are schema-agnostic databases that can handle querying of
	non-sequential data in real-time. It uses tables, rows, and columns,
	<a href="https://en.wikipedia.org/wiki/Relational_database">relational
	database</a>, the names and format of the columns can vary from row
	to row in the same table. A wide-column store can be interpreted as a
	<a href="https://en.wikipedia.org/wiki/Key%E2%80%93value_store">key–value</a>
	<div class='images'><img src='assets/Week 17/11.png'></div>	
    <h2>Key-value stores</h2>
    <p>These types of databases are employed where speed is of utmost
	importance. These are very simple database management systems that
	store key-value pairs. The end goal is to fetch basic data quickly.
	Common use-cases for these types of databases are leaderboards and
	shopping-cart data.</p>
    <h2>Document stores</h2>
	<p>Document stores are databases with flexible schemas. These types of
	databases are best suited to store semi-structured data and can
	handle dynamic querying. Common use-cases for document stores include
	customer data, user-generated content, and order data.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Some factors you should keep in mind when selecting a database management system: </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<h2>Atomicity</h2>
	<p>If
	atomicity is a top priority for you, stick to a relational database.
	Atomicity in database management promotes consistency in a database.
	It rests on the principle of atomic transactions. These are series of
	operations that are considered as a composite operation. In other
	words, either all operations in an atomic transaction occur, or none
	at all. The simplest example of an atomic transaction is transferring
	money from account A to account B. Balance from account A should be
	deducted and the requisite number should be added to account B. Both
	the operations need to be successful for the transaction to be
	successful.</p>
	<h2>Vertical or horizontal scaling</h2>
	<p>
	If your data strategy rests on vertical scaling, a relational
	database is fine. Vertical scaling adds more compute power to a sever
	instead of adding more servers to the system. It is preferred when
	there are limited number of users and not a lot of querying involved.
	In that sense, vertical scaling might be suitable for business-facing
	startups. The basic advantages of vertical scaling are speed and
	simplicity.</p>
	<p>On
	the other hand, if you are expecting higher loads in terms of users
	or querying, horizontal scaling is a much cheaper solution. NoSQL
	databases employ horizontal scaling. Instead of adding more compute
	power to a server, they distribute the load across servers, and
	hence, the name. Horizontal scaling, and in turn, NoSQL databases,
	give businesses more elasticity. However, running join operations is
	difficult on these systems.</p>
	<h2>Speed</h2>
	<p>
	If speed is more important than ACID compliance, a non-relational
	database, such as a document database, is a better bet. For instance,
	in the case of real-time data, such as sensor data, some compromise
	in data integrity can be tolerated in favour of speed. In a
	non-relational database, each record is an independent entity. Thus,
	it is possible to run multiple queries simultaneously irrespective of
	the size of the database.
	</p>
	<h2>Summary</h2>
	<table>
	<col>
	<col>
	<tr>
	<td>
	<p>SQL</p>
			</td>
	<td>
	<p>NoSQL</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>RELATIONAL
				DATABASE MANAGEMENT SYSTEM (RDBMS)</p>
			</td>
	<td>
	<p>Non-relational
				or distributed database system.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>These
				databases have fixed or static or predefined schema</p>
			</td>
	<td>
	<p>They
				have dynamic schema</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>These
				databases are not suited for hierarchical data storage.</p>
			</td>
	<td>
	<p>These
				databases are best suited for hierarchical data storage.</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>These
				databases are best suited for complex queries</p>
			</td>
	<td>
	<p>These
				databases are not so good for complex queries</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Vertically
				Scalable</p>
			</td>
	<td>
	<p>Horizontally
				scalable</p>
			</td>
		</tr>
	<tr>
	<td>
	<p>Follows
				ACID property</p>
			</td>
	<td>
	<p>Follows
				CAP(consistency, availability, partition tolerance)</p>
			</td>
		</tr>
	</table>
	<p><br><br>
	</p>

</mat-expansion-panel>