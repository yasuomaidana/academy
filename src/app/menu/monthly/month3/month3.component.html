<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Summary </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>This
	month I learned several things related to:</p>
	<ul>
	<li><p>Data
		structures</p>
	<li><p>Java</p>
	<li><p>C++</p>
	<li><p>Asynchronous
		events</p>
	<li><p>A
		bit of Python</p>
	<li><p>Design
		patterns</p>
	<li><p>UML</p>
	<li><p>Big O
		notation</p>
	</ul>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Data structures </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>There
	are several types of data structures. However, we could split them
	into linear and no linear. The difference relies on how they manage
	to store the data. While linear data structures store data
	sequentially (they could be directly stored physically next to each
	other or use pointers). Non-linear data structures create branches,
	sections, or rules to store the data.</p>
	<p>Additionally,
	there exists a type of data structure called abstract data
	structures. They are essentially a simple data structure with the big
	difference that we add behavior and properties. For example, if we
	force our database to only access the last item added, we convert it
	to a stack. Now, how this stack is implemented is another history.
	For example, we could implement it using an array or a linked list.</p>
	<p>Since
	data structures are so used, programming languages have their
	packages or libraries to deal with them. It will be very nasty to
	program them any time you are going to use them. For example, in
	JAVA, we have collections. Which are used to creates Arrays, Vectors
	which are used to make Stacks, etc...</p>
	<p>Some
	data structures use &quot;address&quot; to access information. They
	could be called maps, HashMap's, dictionaries, etc... In some
	language programs, you have to define them. For example, in JAVA, a
	map will use a string as a key which value must be an integer.
	Meanwhile, others programming languages like Python
	maps/dictionaries, so some keys could store an integer and other
	objects, etc.</p>
	<p>Furthermore,
	for some languages programs that allow multithreading, some data
	structures can't be accessed from other threads, or you can access
	but not write them. There exist some others that permit you to access
	and write them. Nevertheless, you have to explicitly say when you can
	write them. It is done to protect them since they are being used by
	several threads at the same time. If they were writing them at the
	same time, the information could be lost.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> C++ </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>It
	is a programming language that inserts objects into the C programming
	language. It is a powerful programming language since it still has
	access to low-level instructions. However, as spiderman's uncle says,
	great power means great responsibility. With this programming
	language, you can do several things but are also obligated to declare
	any step or definition. So, you face a trade-off between performance
	and liberty vs. time development and knowledge. One example is memory
	management. While in other programming languages like JAVA, you can
	forget about it in C++, you have to manage it, or your program could
	crash with time easily.</p>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Python </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<ul>
	<li><p>In
		Python exists scripts and modules. The main difference relies on the
		first ones are written to be run but modules to be imported.</p>
	<li><p>Python
		is also a piece of software called an interpreter. The interpreter
		is the program you'll need to run Python code and scripts.
		Technically, the interpreter is a layer of software that works
		between your program and your computer hardware to get your code
		running.</p>
	<li><p>Virtual
		environments have their own site directories, optionally isolated
		from system site directories. Each virtual environment has its own
		Python binary (which matches the version of the binary that was used
		to create this environment) and can have its own independent set of
		installed Python packages in its site directories.</p>
	<li><p>It
		supports multithreading.</p>
	<li><p>It
		is not tail-recursive optimized.</p>
	<li><p>The
		Python interpreter uses a call stack to run a Python program. When a
		function is called in Python, a new frame is pushed onto the call
		stack for its local execution, and every time a function call
		returns, its frame is popped off the call stack. This stack has a
		defined size, so you can get an error when you exceed its size.</p>
	</ul>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Design patterns </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<p>In
	software engineering, a <b>design
	pattern</b>
	is a general repeatable solution to a commonly occurring problem in
	software design. A design pattern isn't a finished design that can be
	transformed directly into code.</p>
	<p>There
	exist three categories of them.</p>
	<ol>
	<li><p>Behavioral
		design patterns: These design patterns are all about Class's objects
		communication. Behavioral patterns are those patterns that are most
		specifically concerned with communication between objects.</p>
	<li><p>Structural
		design patterns. Structural object patterns define ways to compose
		objects to obtain new functionality. These patterns explain how to
		assemble objects and classes into larger structures while keeping
		these structures flexible and efficient.</p>
	<li><p>Creational
		design patterns: Creational design patterns are concerned with<b>
		the way of creating objects.</b>
		These design patterns are used when a decision must be made at the
		time of instantiation of a class (i.e., creating an object of a
		class).</p>
	</ol>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> UML </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    			<div class='images'><img src='assets/Week 14/25.png'></div>	
</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> JAVA </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<ul>
	<li><p>Dependency
		injection is the concept in which objects get other required objects
		from outside.</p>
	<li><p>Here
		I implemented several abstract data structures using raw datatypes.
		I practiced some design patterns concepts.</p>
	<li><p>I
		learned about nested classes.</p>
	<li><p>I
		practiced a lot with some object-oriented concepts, as inheritance,
		encapsulation, and polymorphism.</p>
	</ul>

</mat-expansion-panel>


<mat-expansion-panel hideToggle class="ExpansionPanel">
    <mat-expansion-panel-header class="matPanelTitle">
    <mat-panel-title>
        <p> Big O notation </p>
        </mat-panel-title>
    </mat-expansion-panel-header>
    		<ul>
	<li><p>Big
		O notation is a mathematical notation that describes the limiting
		behavior of a function when the argument tends towards a particular
		value or infinity.”</p>
	<li><p>It
		describes the <b>complexity</b>
		of your code using algebraic terms.</p>
	</ul>
	<p>When
	we calculate big O notation, we only care about the <b>dominant
	terms</b>
	and do not care about the coefficients.</p>
	<h2>Big O Rules</h2>
	<ol>
	<li><p><b>O
		(1) has the least complexity: </b>Often
		called <i>“constant
		time”</i></p>
	<li><p><b>O(log(n))
		is more complex than O (1), but less complex than polynomials</b></p>
	<li><p><b>Complexity
		of polynomials increases as the exponent increases</b></p>
	<li><p><b>Exponentials
		have greater complexity than polynomials as long as the coefficients
		are positive multiples of n </b>O(2ⁿ)
		is more complex than O(n⁹⁹)</p>
	<li><p><b>Factorials
		have greater complexity than exponentials</b></p>
	<li><p><b>Multiplying
		terms: </b>When
		multiplying, the complexity will be greater than the original, but
		no more than the equivalence of multiplying something that is more
		complex.</p>
	<li><p><b>Time
		&amp; Space Complexity: </b>The
		space complexity is related to how much memory the program will use</p>
	</ol>

</mat-expansion-panel>
